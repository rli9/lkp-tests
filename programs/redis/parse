#!/usr/bin/env ruby

LKP_SRC ||= ENV['LKP_SRC'] || File.dirname(__dir__)

require "#{LKP_SRC}/lib/array"
# set_avg = 0
# get_avg = 0
# set_time = 0
# get_time = 0

class RedisParser
  PERCENTILE_STRS = ['90', '95', '99', '99.9'].freeze
  PERCENTILES = PERCENTILE_STRS.map(&:to_f)

  def initialize
    @set_sum = 0
    @set_num = 0
    @get_sum = 0
    @get_num = 0
    @is_set = true
    @set_latencies = []
    @get_latencies = []
    @proc_set_latencies = nil
    @proc_get_latencies = nil
    @set_time_sum = 0
    @set_time_num = 0
    @get_time_sum = 0
    @get_time_num = 0
  end

  def parse(line)
    return if parse_simple_metrics(line)

    case line
    when /====== SET ======$/
      @is_set = true
      @proc_set_latencies = []
    when /====== GET ======$/
      @is_set = false
      @proc_get_latencies = []
    when /  throughput summary: (\d+\.\d+) requests per second$/
      handle_throughput($1)
    when /requests completed in (\d+\.\d+) seconds$/
      handle_completed_time($1)
    when /^(\d+\.\d+)% <= (\d+) milliseconds$/
      handle_latency($1, $2)
    end
  end

  def parse_simple_metrics(line)
    case line
    when /PING_INLINE: (\d+).(\d+) requests per second$/
      puts "PING_INLINE: #{$1}.#{$2}"
    when /PING_BULK: (\d+).(\d+) requests per second$/
      puts "PING_BULK: #{$1}.#{$2}"
    when /INCR: (\d+).(\d+) requests per second$/
      puts "INCR: #{$1}.#{$2}"
    when /LPUSH: (\d+).(\d+) requests per second$/
      puts "LPUSH: #{$1}.#{$2}"
    when /RPUSH: (\d+).(\d+) requests per second$/
      puts "RPUSH: #{$1}.#{$2}"
    when /LPOP: (\d+).(\d+) requests per second$/
      puts "LPOP: #{$1}.#{$2}"
    when /RPOP: (\d+).(\d+) requests per second$/
      puts "RPOP: #{$1}.#{$2}"
    when /SADD: (\d+).(\d+) requests per second$/
      puts "SADD: #{$1}.#{$2}"
    when /HSET: (\d+).(\d+) requests per second$/
      puts "HSET: #{$1}.#{$2}"
    when /SPOP: (\d+).(\d+) requests per second$/
      puts "SPOP: #{$1}.#{$2}"
    when /LPUSH .needed to benchmark LRANGE.: (\d+).(\d+) requests per second$/
      puts "LPUSH_LRANGE: #{$1}.#{$2}"
    when /LRANGE_100 .first 100 elements.: (\d+).(\d+) requests per second$/
      puts "LRANGE_100: #{$1}.#{$2}"
    when /LRANGE_300 .first 300 elements.: (\d+).(\d+) requests per second$/
      puts "LRANGE_300: #{$1}.#{$2}"
    when /LRANGE_500 .first 450 elements.: (\d+).(\d+) requests per second$/
      puts "LRANGE_500: #{$1}.#{$2}"
    when /LRANGE_600 .first 600 elements.: (\d+).(\d+) requests per second$/
      puts "LRANGE_600: #{$1}.#{$2}"
    when /MSET .10 keys.: (\d+).(\d+) requests per second$/
      puts "MSET: #{$1}.#{$2}"
    else
      return false
    end
    true
  end

  def handle_throughput(val)
    if @is_set
      @set_sum += val.to_f
      @set_num += 1
      @set_latencies << @proc_set_latencies
    else
      @get_sum += val.to_f
      @get_num += 1
      @get_latencies << @proc_get_latencies
    end
  end

  def handle_completed_time(val)
    if @is_set
      @set_time_sum += val.to_f
      @set_time_num += 1
    else
      @get_time_sum += val.to_f
      @get_time_num += 1
    end
  end

  def handle_latency(percent, ms)
    ms_val = ms.to_i
    if @is_set
      @proc_set_latencies[ms_val] = percent.to_f
    else
      @proc_get_latencies[ms_val] = percent.to_f
    end
  end

  def print_summary
    puts "set_total_throughput_rps: #{@set_sum}"
    puts "get_total_throughput_rps: #{@get_sum}"

    puts "set_total_time_sec: #{@set_time_sum}"
    puts "get_total_time_sec: #{@get_time_sum}"

    puts "set_avg_throughput_rps: #{safe_div(@set_sum, @set_num)}"
    puts "get_avg_throughput_rps: #{safe_div(@get_sum, @get_num)}"

    puts "set_avg_time_sec: #{safe_div(@set_time_sum, @set_time_num)}"
    puts "get_avg_time_sec: #{safe_div(@get_time_sum, @get_time_num)}"

    normalize_latencies(@set_latencies)
    normalize_latencies(@get_latencies)

    show_latencies(@set_latencies, 'set')
    show_latencies(@get_latencies, 'get')
  end

  def safe_div(sum, count)
    return 0 if count.zero?

    sum / count
  end

  def normalize_latencies(latencies)
    maxcol = latencies.map(&:size).max
    latencies.each do |proc_latencies|
      prev = 0
      (0...maxcol).map do |i|
        percent = proc_latencies[i]
        percent ||= prev
        prev = percent
        proc_latencies[i] = percent
      end
    end
  end

  def show_latencies(latencies, name)
    pi = 0
    latencies.transpose.each_with_index do |ps, i|
      # puts "DEBUG: ps class: #{ps.class}"
      sum = ps.sum
      next unless sum != 0

      avg = sum.to_f / ps.length
      puts "#{name}_latency_#{i}ms%: #{avg}"
      while pi < PERCENTILES.length && avg > PERCENTILES[pi]
        puts "#{name}_latency_#{PERCENTILE_STRS[pi]}%_ms: #{i}"
        pi += 1
      end
      break if avg > PERCENTILES[-1]
    end
  end
end

parser = RedisParser.new
$stdin.each_line do |line|
  parser.parse(line)
end
parser.print_summary
